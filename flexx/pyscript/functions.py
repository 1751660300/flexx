import os
from types import FunctionType
import inspect
import subprocess
import hashlib

from . import Parser


def py2js(pycode):
    """ Translate Python code to JavaScript.
    
    parameters:
        pycode (str): the Python code to transalate.
    
    returns:
        jscode (str): the resulting JavaScript.
    """
    parser = Parser(pycode)
    return parser.dump()


NODE_EXE = None
def get_node_exe():
    """ Small utility that provides the node exe. The first time this
    is called both 'nodejs' and 'node' are tried. To override the
    executable path, set the ``FLEXX_NODE_EXE`` environment variable.
    """
    # This makes things work on Ubuntu's nodejs as well as other node
    # implementations, and allows users to set the node exe if necessary
    global NODE_EXE
    NODE_EXE = os.getenv('FLEXX_NODE_EXE') or NODE_EXE
    if NODE_EXE is None:
        NODE_EXE = 'nodejs'
        try:
            subprocess.check_output([NODE_EXE, '-v'])
        except Exception:  # pragma: no cover
            NODE_EXE = 'node'
    return NODE_EXE


def evaljs(jscode, whitespace=True):
    """ Evaluate JavaScript code in Node.js.
    
    parameters:
        jscode (str): the JavaScript code to evaluate.
        whitespace (bool): if whitespace is False, the whitespace
            is removed from the result.
    
    returns:
        result (str): the last result as a string.
    """
    res = subprocess.check_output([get_node_exe(), '-p', '-e', jscode])
    res = res.decode().rstrip()
    if res.endswith('undefined'):
        res = res[:-9].rstrip()
    if not whitespace:
        res = res.replace('\n', '').replace('\t', '').replace(' ', '')
    return res


def evalpy(pycode, whitespace=True):
    """ Evaluate PyScript code in Node.js (after translating to JS).
    
    parameters
    ----------
    pycode : str
        the PyScript code to evaluate.
    whitespace : bool
        if whitespace is False, the whitespace is removed from the result.
    
    returns
    -------
    result : str
        the last result as a string.
    """
    # delibirate numpy doc style to see if napoleon handles it the same
    return evaljs(py2js(pycode), whitespace)


def script2js(filename, namespace=None, target=None):
    """ Export a .py file to a .js file.
    
    Parameters:
      filename (str): the filename of the .py file to transpile.
      namespace (str): the namespace for this module. (optional)
      target (str): the filename of the resulting .js file. If not given
        or None, will use the ``filename``, but with a ``.js`` extension.
    
    """
    # Import
    assert filename.endswith('.py')
    pycode = open(filename, 'rt').read()
    # Convert
    jscode = Parser(pycode, namespace).dump()
    jscode = '/* Do not edit, autogenerated by flexx.pyscript */\n\n' + jscode
    # Export
    if target is None:
        dirname, fname = os.path.split(filename)
        filename2 = os.path.join(dirname, fname[:-3] + '.js')
    else:
        filename2 = target
    open(filename2, 'wt').write(jscode)


def js(ob, **parser_options):
    """ Get the JavaScript code for a class or function. Can be used
    as a decorator.
    
    Parameters:
        func (class, function): The function or class to transtate. If
            this is already JSCode object, it is returned as-is.
        parser_options: Additional options for the parser. See Parser class
            for details.
    
    Returns:
        jscode (JSCode): An object that has a ``jscode``, ``pycode``
        and ``name`` attribute.
    
    Notes:
        The Python source code for a class is acquired by name.
        Therefore one should avoid decorating classes in modules where
        multiple classes with the same name are defined. This is a
        consequence of classes not having a corresponding code object (in
        contrast to functions).
        
        Function names can be mangled to avoid clashing: "_js"
        is stripped from both ends::
        
            def _js_method_a():
                pass  # becomes "_method_a"
            def method_b_js():
                pass  # becomes "method_b"
    
    """
    
    if isinstance(ob, JSCode):
        return ob
    elif isinstance(ob, type):
        thetype = 'class'
    elif isinstance(ob, FunctionType):
        thetype = 'function'
    else:
        raise ValueError('The js decorator only accepts classes '
                         'and real functions.')
    
    # Get code
    try:
        lines, linenr = inspect.getsourcelines(ob)
    except Exception as err:
        raise ValueError('Could not get source code for object: %s' % err)
    indent = len(lines[0]) - len(lines[0].lstrip())
    lines = [line[indent:] for line in lines]
    if lines[0].startswith('@'):
        code = ''.join(lines[1:])  # decorated function/class
    else:
        code = ''.join(lines)  # object explicitly passed to js()
    
    name = ob.__name__
    return JSCode(thetype, name, code, **parser_options)


def clean_code(code):
    """ Remove duplicate declarations of std function definitions. Use
    this if you build a JS source file from multiple snippets and want
    to get rid of the function declarations like ``_truthy`` and
    ``sum``.
    """
    known_funcs = {}
    
    lines = []
    for line in code.splitlines():
        line2 = line.lstrip()
        indent = len(line) - len(line2)
        if line2.startswith('var ') and ' = function ' in line2:
            prev_indent = known_funcs.get(line2, 999)
            if prev_indent == 0 :
                continue
            if indent == 0:
                known_funcs[line2] = indent
        lines.append(line)
    return '\n'.join(lines)

    
class JSCode(object):
    """ Placeholder for storing the original Python code and the JS
    code for a class or function.
    """
    
    def __init__(self, thetype, name, pycode, **parser_options):
        assert thetype in ('function', 'class')
        self._type = thetype
        self._name = name
        self._pycode = pycode
        
        # Get hash for this code
        # todo: if we are ever going to cahche JS code accross sessions,
        # this string needs to be updated when the pyscript codebase changes
        h = hashlib.sha256('pyscript version 1'.encode())
        h.update(pycode.encode())
        self._hash = h.digest()
        
        p = Parser(pycode, **parser_options)
        code = p.dump()
        
        # Get name - strip "__js" suffix if it's present
        # This allow mangling the function name on the Python side, to allow
        # the same name for a function in both Py and JS. I investigated
        # other solutions, from class-inside-class constructions to
        # black-magic decorators that auto-mangle the function name. I settled
        # on just allowing "func_name__js".
        # todo: only keep latter mangling approach?
        if name.endswith('_js'):
            if thetype == 'function':
                self._name = name = name[:-3].rstrip('_')
                code = code.replace('var %s_js' % name, 'var %s' % name)
                code = code.replace('%s_js = function' % name, '%s = function' % name)
            else:  # pragma: no cover
                raise RuntimeError('Cannot strip "_js" from class defs.')
        if name.startswith('_js'):
            if thetype == 'function':
                self._name = name = name[3:]
                code = code.replace('var _js%s' % name, 'var %s' % name)
                code = code.replace('_js%s = function' % name, '%s = function' % name)
            else:  # pragma: no cover
                raise RuntimeError('Cannot strip "_js" from class defs.')
        
        self._jscode = code
        assert self._jscode[:99].lstrip().startswith('var %s' % name)
    
    @property
    def type(self):
        """ "function" or "class".
        """
        return self._type
    
    @property
    def name(self):
        """ The name of the class or function.
        """
        return self._name
    
    @property
    def jshash(self):
        """ The cryptographic hash (as a 32-element bytes object) for
        this piece of code, based on the PyScript code.
        Two JSCode objects with the same hash are guaranteed to contain
        the same code.
        """
        return self._hash
    
    @property
    def pycode(self):
        """ The Python code that defines this function/class.
        """
        return self._pycode
    
    @property
    def jscode(self):
        """ The resulting JavaScript code for this function/class.
        """
        return self._jscode
    
    def jscode_renamed(self, new_name):
        """ Get the JavaScript code, but with a prefix prepended to the
        class/function name. This also removes the ``var name;``.
        """
        assert new_name
        code = self.jscode
        code = code.replace('%s = function' % self._name, '%s = function' % (new_name), 1)
        code = code.replace('%s.prototype' % self._name, '%s.prototype' % new_name)
        if '.' in new_name:
            code = code.replace('var %s;\n' % self._name, '', 1)
        else:
            code = code.replace('var %s;\n' % self._name, 'var %s;\n' % new_name, 1)
        return code
    
    def __call__(self, *args, **kwargs):
        action = {'function': 'call', 'class': 'instantiate'}[self._type]
        raise RuntimeError('Cannot %s a JS %s directly from Python' %
                           (action, self._type))
    
    def __repr__(self):
        
        return '<JSCode %s (print to see code) at 0x%x>' % (self._type,
                                                            id(self))
    
    def __str__(self):
        pytitle = '== Python code that defines this %s ==' % self._type
        jstitle = '== JS Code that represents this %s ==' % self._type
        return pytitle + '\n' + self.pycode + '\n' + jstitle + self.jscode
